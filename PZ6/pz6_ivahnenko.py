# Вариант 9

# 1. Дан целочисленный список размера 10. Вывести вначале все содержащиеся в данном
# списке четные числа в порядке возрастания их индексов, а затем — все нечетные
# числа в порядке убывания их индексов.

my_list = [23, 14, 8, 17, 5, 10, 32, 20, 11, 7]  # Создание списка из чисел

even_numbers = []  # Инициализация списка для четных чисел
odd_numbers = []  # Инициализация списка для нечетных чисел

for i in range(len(my_list)):  # Цикл для перебора индексов элементов списка
    if my_list[i] % 2 == 0:  # Проверка четности текущего числа
        even_numbers.append(my_list[i])  # Добавление четного числа в список четных чисел
    else:
        odd_numbers.append(my_list[i])  # Добавление нечетного числа в список нечетных чисел

print("Четные числа в порядке возрастания индексов:", even_numbers)  # Вывод четных чисел по возрастанию индексов
print("Нечетные числа в порядке убывания индексов:", odd_numbers[::-1])  # Вывод нечетных чисел в обратном порядке индексов [::-1]- инвент порядка элементов


#-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

# 2. Дан список размера N. Найти количество участков, на которых его элементы
# монотонно убывают.


def count_decreasing_sections(lst):
    decreasing_sections = 0  # Инициализация счетчика убывающих участков
    length = len(lst)  # Получение длины списка

    # Проверка каждой пары соседних элементов в списке
    for i in range(1, length):
        # Если текущий элемент меньше предыдущего, это начало нового участка убывания
        if lst[i] < lst[i - 1]:
            decreasing_sections += 1  # Увеличение счетчика убывающих участков

    return decreasing_sections  # Возврат общего количества убывающих участков

# Пример списка для тестирования
my_list = [5, 4, 3, 8, 6, 2, 1, 7, 9]

# Получение количества участков, на которых элементы убывают
result = count_decreasing_sections(my_list) 
print("Количество участков убывания:", result)  # Вывод количества убывающих участков на экран


#-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*

# 3. Дано множество A из N точек на плоскости и точка B (точки заданы своими
# координатами х, у). Найти точку из множества A, наиболее близкую к точке B.
# Расстояние R между точками с координатами (x1, y1) и (x2, у2) вычисляется по
# формуле:
# R = √(x2 – x1)2 + (у2 – y1)2
# .
# Для хранения данных о каждом наборе точек следует использовать по два список: первый
# список для хранения абсцисс, второй — для хранения ординат.


def distance(point1, point2):
    # Функция для вычисления расстояния между двумя точками на плоскости по формуле Евклида
    return ((point2[0] - point1[0]) ** 2 + (point2[1] - point1[1]) ** 2) ** 0.5

def closest_point_to_b(points_x, points_y, point_b):
    min_distance = float('inf')  # Инициализация минимального расстояния
    closest_point = None  # Инициализация ближайшей точки

    for x, y in zip(points_x, points_y):  # Параллельный перебор координат точек
        # Вычисление расстояния между текущей точкой и точкой B
        dist = distance((x, y), point_b)

        # Обновление значения ближайшей точки, если найдено более близкое расстояние
        if dist < min_distance:
            min_distance = dist
            closest_point = (x, y)

    return closest_point  # Возвращаем ближайшую точку к точке B из множества A

# Пример данных
points_x = [1, 3, 7, 9, 12]
points_y = [4, 6, 2, 15, 9]
point_b = (8, 10)

# Поиск ближайшей точки к точке B из множества A
closest = closest_point_to_b(points_x, points_y, point_b)
print("Ближайшая точка к B из множества A:", closest)  # Вывод ближайшей точки к точке B из множества A


# Поиск ближайшей точки к точке B из множества A
closest = closest_point_to_b(points_x, points_y, point_b)
print("Ближайшая точка к B из множества A:", closest)  # Вывод ближайшей точки к точке B из множества A
